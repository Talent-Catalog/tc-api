package org.tctalent.anonymization.exception;

import com.fasterxml.jackson.databind.exc.ValueInstantiationException;
import jakarta.validation.ConstraintViolationException;
import java.util.stream.Collectors;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ProblemDetail;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

/**
 * Global exception handler that converts exceptions into Problem Details responses.
 * <p>
 * It can override exception handles if needed. For example to process validation errors (e.g.
 * MethodArgumentNotValidException) and deserialization errors (e.g. HttpMessageNotReadableException)
 *
 * @see ResponseEntityExceptionHandler
 * @see ProblemDetail
 * @see MethodArgumentNotValidException
 * @see HttpMessageNotReadableException
 * @author sadatmalik
 */
@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

  /**
   * This generates ProblemDetail responses for parameter constraint notations generated by
   * the OpenAPI.
   * For example the @Min(1) annotation associated with the limit parameter of CandidateController
   * getAllCandidates.
   * @param ex Constraint exception
   * @return Associated ProblemDetail
   */
  @ExceptionHandler(ConstraintViolationException.class)
  public ProblemDetail handleConstraintViolationException(ConstraintViolationException ex) {
    return ProblemDetail.forStatusAndDetail(HttpStatus.BAD_REQUEST, ex.getMessage());
  }

  /**
   * Handles standard TC NoSuchObjectException.
   * <p/>
   * See <a href="https://www.baeldung.com/spring-boot-return-errors-problemdetail">...</a>
   * @param ex NoSuchObjection exception containing details
   * @return ProblemDetail
   */
  @ExceptionHandler(NoSuchObjectException.class)
  public ProblemDetail handleNoSuchObjectException(NoSuchObjectException ex) {
      return ProblemDetail.forStatusAndDetail(HttpStatus.BAD_REQUEST, ex.getMessage());
  }

  /**
   * Handles validation errors when a controller method argument annotated with @Valid fails.
   * <p>
   * Aggregates all field error messages into a single error string and wraps it in a
   * ProblemDetail object with a BAD_REQUEST (400) status. The response is then built using
   * a helper method defined in Spring's ResponseEntityExceptionHandler.
   *
   * @param ex the exception containing validation errors
   * @param headers the HTTP headers of the request
   * @param status the HTTP status code
   * @param request the current web request
   * @return a ResponseEntity containing a ProblemDetail body with status 400
   */
  @Override
  protected ResponseEntity<Object> handleMethodArgumentNotValid(
      MethodArgumentNotValidException ex,
      HttpHeaders headers,
      HttpStatusCode status,
      WebRequest request) {

    String errors = ex.getBindingResult().getFieldErrors().stream()
        .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
        .collect(Collectors.joining("; "));

    if (errors.isBlank()) {
      errors = "Validation failed for the request.";
    }

    ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(HttpStatus.BAD_REQUEST, errors);
    return createResponseEntity(problemDetail, headers, status, request);
  }

  /**
   * Handles HttpMessageNotReadableException by checking if the underlying cause is a
   * ValueInstantiationException caused by an IllegalArgumentException. If so, it constructs a
   * ProblemDetail response with a 400 Bad Request status using the error message. Otherwise, it
   * delegates to the default exception handling.
   * <p>
   * This is useful when a ValueInstantiationException is thrown due to an invalid enum value in a
   * request body. The exception is caught, and the error message is extracted from the
   * IllegalArgumentException and returned in the response.
   *
   * @param ex the HttpMessageNotReadableException encountered during request deserialization
   * @param headers the HTTP headers associated with the request
   * @param status the HTTP status code
   * @param request the current web request
   * @return a ResponseEntity containing a ProblemDetail with a 400 status if a specific cause is
   * found, or the default handling response otherwise
   */
  @Override
  protected ResponseEntity<Object> handleHttpMessageNotReadable(
      HttpMessageNotReadableException ex,
      HttpHeaders headers,
      HttpStatusCode status,
      WebRequest request) {

    // Check if the cause is a ValueInstantiationException
    Throwable cause = ex.getCause();
    if (cause instanceof ValueInstantiationException vie) {
      // Retrieve the inner cause
      Throwable innerCause = vie.getCause();
      if (innerCause instanceof IllegalArgumentException iae) {
        String message = iae.getMessage();
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(HttpStatus.BAD_REQUEST, message);
        return createResponseEntity(problemDetail, headers, status, request);
      }
    }

    // Fallback to default handling if it's not the exception we're expecting
    return super.handleHttpMessageNotReadable(ex, headers, status, request);
  }

}
